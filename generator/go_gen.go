package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/snowmerak/socketgen/parser"
)

const goTemplate = `// Code generated by socketgen. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"google.golang.org/protobuf/proto"
)

type PacketHandler interface {
{{- range .Payloads }}
	On{{.Name}}(header *Header, msg *{{.Name}})
{{- end }}
}

func Dispatch(data []byte, handler PacketHandler) error {
	pkt := &GamePacket{}
	if err := proto.Unmarshal(data, pkt); err != nil {
		return err
	}

	switch payload := pkt.Payload.(type) {
{{- range .Payloads }}
	case *GamePacket_{{.Name}}:
		handler.On{{.Name}}(pkt.Header, payload.{{.Name}})
{{- end }}
	default:
		return fmt.Errorf("unknown packet type")
	}
	return nil
}

type PacketStream interface {
	ReadPacket() ([]byte, error)
	WritePacket([]byte) error
}

func Serve(stream PacketStream, handler PacketHandler) error {
	for {
		data, err := stream.ReadPacket()
		if err != nil {
			return err
		}
		if err := Dispatch(data, handler); err != nil {
			fmt.Println(fmt.Errorf("dispatch error: %w", err))
			continue
		}
	}
}

{{- range .Payloads }}

func Send{{.Name}}(stream PacketStream, header *Header, msg *{{.Name}}) error {
	pkt := &GamePacket{
		Header: header,
		Payload: &GamePacket_{{.Name}}{
			{{.Name}}: msg,
		},
	}
	data, err := proto.Marshal(pkt)
	if err != nil {
		return err
	}
	return stream.WritePacket(data)
}
{{- end }}
`

func GenerateGo(result *parser.ParseResult, outDir string) error {
	tmpl, err := template.New("go").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse go template: %w", err)
	}

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outFile := filepath.Join(outDir, "packet_dispatcher.go")
	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	// Prepare data for template
	// We might need to adjust package name or imports depending on where this file is placed relative to the generated proto code.
	// For now, we assume it's in the same package as the generated proto code (e.g. "packet").

	// Capitalize payload names for Go export rules if needed, but usually proto generates CamelCase structs.
	// The parser returns TypeName like "LoginReq".

	return tmpl.Execute(f, result)
}
