package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/snowmerak/socketgen/parser"
)

const tsTemplate = `// Code generated by socketgen. DO NOT EDIT.
import { {{.PackageName}} } from "./packet"; // Adjust import path as needed

const { GamePacket, Header, {{ range .Payloads }}{{ .Name }}, {{ end }} } = {{.PackageName}};
type Header = {{.PackageName}}.Header;
{{- range .Payloads }}
type {{.Name}} = {{$.PackageName}}.{{.Name}};
{{- end }}

export interface IPacketHandler {
{{- range .Payloads }}
  on{{.Name}}(header: Header, msg: {{.Name}}): void;
{{- end }}
}

export function dispatch(data: Uint8Array, handler: IPacketHandler) {
  const pkt = GamePacket.decode(data);
  
{{- range $i, $p := .Payloads }}
  {{if eq $i 0}}if{{else}}else if{{end}} (pkt.{{.FieldName | toCamelCase}}) {
    handler.on{{.Name}}(pkt.header!, pkt.{{.FieldName | toCamelCase}}!);
  }
{{- end }}
}

export interface IPacketStream {
  readPacket(): Promise<Uint8Array>;
  writePacket(data: Uint8Array): Promise<void>;
}

export async function serve(stream: IPacketStream, handler: IPacketHandler) {
  while (true) {
    const data = await stream.readPacket();
    dispatch(data, handler);
  }
}

{{- range .Payloads }}

export async function send{{.Name}}(stream: IPacketStream, header: Header, msg: {{.Name}}): Promise<void> {
  const pkt = GamePacket.fromPartial({
    header: header,
    {{.FieldName | toCamelCase}}: msg,
  });
  const data = GamePacket.encode(pkt).finish();
  await stream.writePacket(data);
}
{{- end }}
`

func GenerateTS(result *parser.ParseResult, outDir string) error {
	funcMap := template.FuncMap{
		"toCamelCase": toCamelCase,
	}

	tmpl, err := template.New("ts").Funcs(funcMap).Parse(tsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse ts template: %w", err)
	}

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outFile := filepath.Join(outDir, "PacketDispatcher.ts")
	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	return tmpl.Execute(f, result)
}
