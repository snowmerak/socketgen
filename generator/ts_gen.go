package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/snowmerak/socketgen/parser"
)

const tsTemplate = `// Code generated by socketgen. DO NOT EDIT.
import { {{.PackageName}} } from "./packet"; // Adjust import path as needed

const { GamePacket, Header, {{ range .Payloads }}{{ .Name }}, {{ end }} } = {{.PackageName}};
type Header = {{.PackageName}}.Header;
{{- range .Payloads }}
type {{.Name}} = {{$.PackageName}}.{{.Name}};
{{- end }}

export interface IPacketHandler {
{{- range .Payloads }}
  on{{.Name}}(header: Header, msg: {{.Name}}): void;
{{- end }}
}

export function dispatch(data: Uint8Array, handler: IPacketHandler) {
  const pkt = GamePacket.decode(data);
  
{{- range $i, $p := .Payloads }}
  {{if eq $i 0}}if{{else}}else if{{end}} (pkt.{{.FieldName | toCamelCase}}) {
    handler.on{{.Name}}(pkt.header!, pkt.{{.FieldName | toCamelCase}}!);
  }
{{- end }}
}
`

func toCamelCase(s string) string {
	// snake_case to camelCase
	// e.g. login_req -> loginReq
	// If it's already camelCase or PascalCase, we might need to handle it.
	// But proto field names are usually snake_case.

	// Simple implementation for snake_case to camelCase
	var result strings.Builder
	nextUpper := false
	for i, r := range s {
		if r == '_' {
			nextUpper = true
			continue
		}
		if i == 0 {
			result.WriteRune(unicode.ToLower(r))
		} else if nextUpper {
			result.WriteRune(unicode.ToUpper(r))
			nextUpper = false
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func GenerateTS(result *parser.ParseResult, outDir string) error {
	funcMap := template.FuncMap{
		"toCamelCase": toCamelCase,
	}

	tmpl, err := template.New("ts").Funcs(funcMap).Parse(tsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse ts template: %w", err)
	}

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	outFile := filepath.Join(outDir, "PacketDispatcher.ts")
	f, err := os.Create(outFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	return tmpl.Execute(f, result)
}
